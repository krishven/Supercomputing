#include <iostream>
#include <cilk.h>
#include <cilkview.h>
#include <stdint.h>
#include <algorithm>
#include<stdio.h>
using namespace std;

#define M2 2
#define M3 2
#define N 8192

void swap(int &a1, int &a2) {
	int t = a1;
	a1 = a2;
	a2 = t;
}

void serial_merge(int T[], int p1, int r1, int p2, int r2, int A[], int p3, int r3)
{
	int i = p1, j = p2, k = p3;

	while (i <= r1 && j <= r2 && k <= r3) {
		if (T[i] <= T[j]) {
			A[k] = T[i];
			i++;
		}
		else {
			A[k] = T[j];
			j++;
		}
		k++;
	}
	while (i <= r1 && k <= r3) {
		A[k] = T[i];
		k++;
		i++;
	}
	while (j <= r2 && k <= r3) {
		A[k] = T[j];
		k++;
		j++;
	}
}

int binary_search(int k, int T[], int l, int r) {
	int m;
	r = max(l, r + 1);

	while (l < r)
	{
		m = l + (r - l) / 2;
		if (T[m] <= k && T[m] > k)
			return m + 1;
		if (T[m] < k)
			l = m + 1;
		else
			r = m;
	}
	return r;
}

void sort(int arr[], int l, int r) {
	int i, key, j;
	for (i = l + 1; i <= r; i++)
	{
		key = arr[i];
		j = i - 1;
		while (j >= l && arr[j] > key)
		{
			arr[j + 1] = arr[j];
			j = j - 1;
		}
		arr[j + 1] = key;
	}
}

void par_merge(int T[], int p1, int r1, int p2, int r2, int A[], int p3)
{
	int n1, n2, r3;


	n1 = r1 - p1 + 1, n2 = r2 - p2 + 1, r3 = p3 + n1 + n2 - 1;

	if (n1 + n2 <= M2)
		serial_merge(T, p1, r1, p2, r2, A, p3, r3);
	else {
		if (n1 < n2) {
			swap(p1, p2);
			swap(r1, r2);
			swap(n1, n2);
		}
		int q1 = (p1 + r1) / 2;
		int q2 = binary_search(T[q1], T, p2, r2);
		int q3 = p3 + (q1 - p1) + (q2 - p2);

		A[q3] = T[q1];

		cilk_spawn par_merge(T, p1, q1 - 1, p2, q2 - 1, A, p3);
//		par_merge(T, p1, q1 - 1, p2, q2 - 1, A, p3);
		par_merge(T, q1 + 1, r1, q2 , r2, A, q3 + 1);
		cilk_sync;
	}
}

void par_merge_sort_pm(int A[], int T[], int p, int r)
{
	int i, size, q;
	int n = r - p + 1;

	if (n <= M3)
		sort(A, p, r);
	else {
		q = (p + r) / 2;

	cilk_spawn par_merge_sort_pm(A, T, p, q);
//	par_merge_sort_pm(A, p, q);
	par_merge_sort_pm(A, T, q + 1, r);
	cilk_sync;

	for (i = p; i <= r; i++)
		T[i] = A[i];

	par_merge(T, p, q, q + 1, r, A, p);
	}
}

int cilk_main() {
	int n = N, i;
	int m = 2;
	int A[N], T[N];

	for (i = 0; i < n; i++) {
		A[i] = n - i;
	}

	cilk::cilkview cv;
	cv.start();

	par_merge_sort_pm(A, T, 0, n - 1);

	cv.stop();
	cv.dump("results", false);
	cout << "M: " << m << " " << cv.accumulated_milliseconds() / 1000.f << " seconds" << endl;

	for (i = 0; i < n; i++)
		cout << A[i] << "\t";
	cout << "\n";

	return 0;
}
